Include: func.vader
Before:
  let g:ale_silence_TESTING = 1
  let g:ale_loaded = 1
  runtime plugin/ale-silence.vim

  let g:ale_linter_silence_directive = {
    \ 'test1': {
      \ 'inline': '# test1-inline: %s',
      \ 'nextline': '# test1-nextline: %s',
      \ 'start':    '# test1-disable: %s',
      \ 'end':      '# test1-enable: %s',
      \ 'file':     '# test1-file: %s'
    \ },
    \ 'test2': {
      \ 'inline': '# test2-inline: %s',
      \ 'nextline': '# test2-nextline: %s',
      \ 'start':    '# test2-disable: %s',
      \ 'end':      '# test2-enable: %s',
      \ 'file':     '# test2-file: %s'
    \ },
    \ 'inline-only': {
      \ 'inline': '# inline-only: %s'
    \ },
    \ 'nextline-only': {
      \ 'nextline': '# nextline-only: %s'
    \ },
  \ }


  let Entry1 = EntryFor('test1')
  let Entry2 = EntryFor('test2')
  let InlineOnly = EntryFor('inline-only')
  let NextlineOnly = EntryFor('nextline-only')
  let Rubocop = EntryFor('rubocop')

Execute (ale#silence#Format returns a directive formatter function):
  let FmtDir = ale#silence#Format('linter: %s')
  AssertEqual 'linter: hello directive', FmtDir(['hello', 'directive'])

Execute (ale#silence#Format can take a separator):
  let FmtDir = ale#silence#Format('linter: %s', ', ')
  AssertEqual 'linter: hello, directive', FmtDir(['hello', 'directive'])

Execute (s:partition partitions a list by key):
  let list = [{'a': 1}, {'a': 1}, {'a': 2}, {'a': 3}, {'a': 3}]
  let expected = [[{'a': 1}, {'a': 1}], [{'a': 2}], [{'a': 3}, {'a': 3}]]
  AssertEqual expected, S('partition', list, 'a')

Given ruby:
  def foo
    :bar
  end

Execute:
  let bnr = bufnr('')
  call S('disable_inline', [Entry1(bnr, 1, 'error2')])
  call S('disable_inline', [
      \ Entry1(bufnr(''), 2, 'error1'),
      \ Entry2(bufnr(''), 2, 'error1')
      \ ])
  call S('disable_inline', [])

Expect ruby (s:disable_inline silences inline linewise):
  def foo # test1-inline: error2
    :bar # test1-inline: error1 # test2-inline: error1
  end

Execute:
  let bnr = bufnr('')
  call S('disable_next_line', [Entry1(bnr, 1, 'error2')])
  call S('disable_next_line', [
      \ Entry1(bufnr(''), 3, 'error1'),
      \ Entry2(bufnr(''), 3, 'error1')
      \ ])
  call S('disable_next_line', [])

Expect ruby (s:disable_next_line silences inline next line):
  # test1-nextline: error2
  def foo
    # test1-nextline: error1 # test2-nextline: error1
    :bar
  end

Given ruby:
  def foo
    if bar
      :bar
    else
      :baz
    end
  end

Execute:
  let bnr = bufnr('')
  call S('disable_range', [Entry1(bnr, 1, 'error2')], 1, 7)
  call S('disable_range', [
      \ Entry1(bufnr(''), 3, 'error1'),
      \ Entry2(bufnr(''), 3, 'error1')
      \ ], 3, 7)

Expect ruby (s:disable_range silences in range):
  # test1-disable: error2
  def foo
    # test1-disable: error1 # test2-disable: error1
    if bar
      :bar
    else
      :baz
    end
    # test1-enable: error1 # test2-enable: error1
  end
  # test1-enable: error2

Given ruby:
  def foo
    :bar
  end

Execute:
  let bnr = bufnr('')
  call S('disable_file', [
      \ Entry1(bnr, 1, 'error2'),
      \ Entry1(bnr, 3, 'error1'),
      \ Entry2(bnr, 3, 'error1')
      \ ], 1)

Expect ruby (s:disable_file silences whole file):
  # test1-file: error1 error2
  # test2-file: error1
  def foo
    :bar
  end

Execute:
  let bnr = bufnr('')
  call SetBufferInfo(bnr,
  \ Entry1(bnr, 1, 'error2'),
  \ Entry1(bnr, 2, 'error1'),
  \ Entry2(bnr, 2, 'error1')
  \)

Do:
  1j
  :ALESilence\<CR>

Expect ruby (:ALESilence silences errors on current line):
  def foo
    # test1-nextline: error1 # test2-nextline: error1
    :bar
  end

Execute:
  let bnr = bufnr('')
  call SetBufferInfo(bnr,
  \ Entry1(bnr, 3, 'error2'),
  \ Entry1(bnr, 2, 'error1'),
  \ Entry2(bnr, 2, 'error1')
  \)

Do:
  :ALESilence!\<CR>

Expect ruby (:ALESilence! silences whole file when no error on current line):
  # test1-file: error1 error2
  # test2-file: error1
  def foo
    :bar
  end

Do:
  :ALESilence! test1:error1\<CR>

Expect ruby (:ALESilence! can take arguments):
  # test1-file: error1
  def foo
    :bar
  end

Do:
  j
  :ALESilence test2:error1\<CR>

Expect ruby (:ALESilence can take arguments):
  def foo
    # test2-nextline: error1
    :bar
  end

Do:
  v2j
  :'<,'>ALESilence\<CR>

Expect ruby (:ALESilence can silence a range):
  # test1-disable: error1 error2 # test2-disable: error1
  def foo
    :bar
  end
  # test1-enable: error1 error2 # test2-enable: error1

Do:
  v2j
  :'<,'>ALESilence test1:error1 test2:error1\<CR>

Expect ruby (:ALESilence can silence a range with arguments):
  # test1-disable: error1 # test2-disable: error1
  def foo
    :bar
  end
  # test1-enable: error1 # test2-enable: error1


Execute:
  let bnr = bufnr('')
  call SetBufferInfo(bnr,
  \ InlineOnly(bnr, 1, 'error1'),
  \)

Do:
  :ALESilence\<CR>

Expect ruby (:ALESilence uses inline if nextline is not available):
  def foo # inline-only: error1
    :bar
  end

Execute:
  let bnr = bufnr('')
  call SetBufferInfo(bnr,
  \ InlineOnly(bnr, 1, 'error1'),
  \ NextlineOnly(bnr, 1, 'error1')
  \)

Do:
  :ALESilence\<CR>

Expect ruby (:ALESilence handles mix of inline and nextline):
  # nextline-only: error1
  def foo # inline-only: error1
    :bar
  end

Execute:
  let bnr = bufnr('')
  call SetBufferInfo(bnr,
  \ InlineOnly(bnr, 1, 'error1'),
  \ NextlineOnly(bnr, 1, 'error1'),
  \ InlineOnly(bnr, 3, 'error1'),
  \ NextlineOnly(bnr, 3, 'error1')
  \)
Do:
  :1,3ALESilence\<CR>

Expect ruby (:ALESilence uses nextline if range is not available):
  # nextline-only: error1
  def foo # inline-only: error1
    :bar
  # nextline-only: error1
  end # inline-only: error1

Execute:
  let bnr = bufnr('')
  call SetBufferInfo(bnr,
  \ InlineOnly(bnr, 1, 'error1'),
  \ InlineOnly(bnr, 3, 'error1'),
  \ NextlineOnly(bnr, 1, 'error1'),
  \ NextlineOnly(bnr, 3, 'error1'),
  \ Entry1(bnr, 1, 'error1'),
  \ Entry1(bnr, 3, 'error1'),
  \)

Do:
  :1,3ALESilence\<CR>

Expect ruby (:ALESilence handles mix of range, inline and nextline):
  # test1-disable: error1
  # nextline-only: error1
  def foo # inline-only: error1
    :bar
  # nextline-only: error1
  end # inline-only: error1
  # test1-enable: error1

Execute (ale_linters#<linter>#GetSilenceDirectives gets directives):
  let d = ale_silence#rubocop#GetSilenceDirectives()
  Assert type(d) is v:t_dict

Execute (s:set_nested sets a value in nested dictionaries):
  call S('set_nested', g:, 'value', 'key1', 'key2', 'key3')
  AssertEqual 'value', g:key1.key2.key3

Given ruby:
  def foo
    :bar
  end

Execute:
  let nr = bufnr('')
  let g:ale_silence_TESTING_winbufnr = nr
  call SetBufferInfo(bnr,
    \ Rubocop(bnr, 1, 'error1'),
    \ Rubocop(bnr, 3, 'error2')
    \)

Execute (ale#silence#List returns list of strings describing directives):
  AssertEqual [
    \ '==== rubocop ====',
    \ 'file       # rubocop: disable <err1> <err2> ...',
    \ 'inline     # rubocop: disable <err1> <err2> ...',
    \ 'start      # rubocop: disable <err1> <err2> ...',
    \ 'end        # rubocop: enable <err1> <err2> ...'
    \ ], ale#silence#List()

Execute (ale#silence#complete only provides errors for current line):
  AssertEqual join([
    \ 'rubocop:error1'
    \], "\n"), ale#silence#complete('', 'ALESilence', '')
  Log g:ale_buffer_info
