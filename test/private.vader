Include: func.vader
Before:
  let g:ale_silence_TESTING = 1
  let g:ale_loaded = 1
  " runtime plugin/ale-silence.vim
  runtime autoload/ale/silence.vim

Execute (s:parse_cmd_line determines range from command line):
  let bnr = bufnr('')

  AssertEqual [ bnr,
    \ line("'<"),
    \ line("'>"),
    \], S('parse_cmd_line', "'<,'>ALESilence", [bnr]),
    \ "should parse range marks"

  AssertEqual [ bnr,
    \ 1,
    \ 3,
    \], S('parse_cmd_line', '1,3ALESilence', [bnr]),
    \ "should handle explicit range"

  AssertEqual [ bnr,
    \ 1,
    \], S('parse_cmd_line', '1ALESilence', [bnr]),
    \ "should handle single line"

  AssertEqual [ bnr,
    \ line('.')
    \], S('parse_cmd_line', 'ALESilence', [bnr]),
    \ "should return only current line without bang"

  AssertEqual [ bnr,
    \], S('parse_cmd_line', 'ALESilence!', [bnr]),
    \ "should return no range with bang"

Execute (s:filter_range returns errors in range):
  let E = EntryFor('test')
  let bnr = bufnr('')
  let line1 = E(bnr, 1, 'error1')
  let line2 = E(bnr, 2, 'error2')
  let line3 = E(bnr, 3, 'error3')
  call SetBufferInfo(bnr, line1, line2, line3)

  AssertEqual [line1, line2], S('filter_range', bnr, 1, 2)
  AssertEqual [line2], S('filter_range', bnr, 2)
  AssertEqual [line1, line2, line3], S('filter_range', bnr)
